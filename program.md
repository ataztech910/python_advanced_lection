Курс Python продвинутый уровень
=================================================
Это курс для продвинутых разработчиков на языке Python и надеюсь что вы 
еще не забыли как пользоваться языком и просейшими элементами языка.
Сегодня поговорим и том как применять начальные знания о языке 
в реальных задачах. Какие методы программирования мы можем использовать. Какие задачи мы можем решить. Рассмотрим методы оптимизации кода и его тестирование. Рассмотрим 
инструменты профессиональной разработки, а так же узнаем как размещать свой код в сети интернет так чтобы мы могли обращаться к нашим функциям в любой момент. Рассмотрим публикацию нашего кода на Амазон и попробуем автоматизировать часть ежедневных рутинных задач с помощью Python.

---

Лучшие практики программирования на языке Python.
=================================================
Преждечем приступить к разработке наших учебных проектов поговорим и такой вещи как 
Best Practice в языке и научимся пользоваться подходами и инструментами, которые 
используют практически все профессиональные разработчики языка.
Начнем с IDE, если вы еще не используете PyCharm то самое время скачать. Если вы уже 
используете его то двигаемся дальше.

---

Рассмотрим IDE
--------------
Ссылка для скачивания IDE https://www.jetbrains.com/pycharm/
Положительные и отрицательные моменты использования IDE
    
    Плюсы:

    1. Для крупных проектов индексирование упрощает навигацию по проекту
    2. Есть умные подсказки по написанию
    3. Поиск по проекту тоже более интуитивный
    4. Автоматический рефакторинг кода во всех вхождениях нужной строки
    5. Создание схем запуска
    6. Удобная работа с гит из редактора
    7. Хранение истории изменений локального кода
    8. Удобная работа с докер контейнерами из редактора
    9. Интуитивный дебагинг кода

    Минусы:

    1. Требует больше ресурсов для работы
    2. Для ноутбуков может быть критично из-за потребления энергии и батареи
    3. Может долго загружать проект
    4. Сложный инструмент для небольших проектов

Обязательно ставим Material тему и Rainbow плагин для более явного видения кода
Я для презентации буду использовать светлую тему, чтобы вам как в красной шапочке -
было лучше видно. Кроме того в самой последней версии доавилась возможность совместной работы и видео звонков. В условиях КОВИД-19 это очень удобная функция, чтобы можно было работать удаленно в любой распределенной команде.

Структура проекта. С чего начать и не создавать лишнего 
-------------------------------------------------------
    1. Версии
    Версии это важно и встречаются во всех видах программного обеспечения, которым 
    Вы когда либо пользовались и будету пользоваться. Приложение без версии - это 
    никогда не выпущенное приложение. Инструкции по оперированию версиями уже есть 
    на офицальном сайте Python, чтобы просто принять и использовать версионность,
    понятную всем разработчикам. Идентификатор этой спецификации PEP 440 и более подробно прочитать можно тут https://www.python.org/dev/peps/pep-0440/. Абсолютно 
    все требования спецификации я не буду обсуждать, но возьму простейшую выжимку, 
    чтобы можно было ими пользоваться.
    
    Сложный и не сильно непонятный вариант: 
    N[.N]+[{a|b|c|rc}N][.postN][.devN]
    Резулярное выражение, которое подчиняется требованию написания версии приложения

    Простой понятный вариант:
    1.3.4
    В этом случае мы получаем первую версию приложения, в которое вносилось 3 мажорных
    изменения (больших) и 4 минорных (небольших)

    Чуть расширим  1.3.4.5 - мы внесли 5 микроизменений (очень небольших)

    И  1.3.4.5.dev версия приложения не для продакшн. 
    
    Таким образом мы можем оперировать версиями нашего приложения. Единственная сложность - определение размера. Нам придется на практике определить что будет являться большим, что будет не больгим изменением. Так для функции в 100 строк 
    изменение 60 строк будет считаться большим. Но для проекта в 10к строк - 60 возможно будет микро размером.

    2. Стиль кода и автопроверки Вашего кода
    Стиль кода очень субьективный предмет. У каждого он свой и иногда разработчики очень болезненно относятся к изменениям или другим правилам. Но слава богу у Питона есть официальный свод правил написания кода прямо на официальном сайте 
    помотреть можно тут https://www.python.org/dev/peps/pep-0008/#introduction. Здесь же можно встретить правило из сериала "Селиконовая Долина" - что использовать пробелы или табы. В питоне это пробелы. Но спасибо умной IDE мы можем исползовать таб и он будет автоматически ставить пробелы.
    
    Кроме того у нас есть множество инструментов как pep8 для автоматических правок нашего когда по правилам из спецификаций. Для этого можем использовать команду в строке `pep8 hello.py` и получим ответ на каких строкам мы допустили стилевые ошибки и их необходимо поправить. 

    Для чего нам необходимо поддерживать стиль и аккуратность кода ? Ответ простой - для того, чтобы мы могли работать в распределенных коммандах. Код долджен быть максимально абстрактный и привязан к принятыми в комманде правилам.


    That was one of the first questions raised in the community, so the Python folks, in their vast wisdom, came up with the PEP 8: Style Guide for Python Code

    - Use four spaces per indentation level.
    - Limit all lines to a maximum of 79 characters.
    - Separate top-level function and class definitions with two blank lines.
    - Encode files using ASCII or UTF-8.
    - Use one module import per import statement and per line. Place import statements at the top of the file, after comments and docstrings, grouped first by standard, then by third party, and finally by local library imports.
    - Do not use extraneous whitespaces between parentheses, square brackets, or braces or before commas.
    - Write class names in camel case (e.g., CamelCase), suffix exceptions with Error (if applicable), and name functions in lowercase with words and underscores (e.g., separated_by_underscores). Use a leading underscore for _private attributes or methods.

    Кроме того можно снарядить наш редактор плагинами типа Pyflakes (https://launchpad.net/pyflakes/) или Pylint (https://pypi.org/project/pylint/)



Модули, библиотеки и фрэймворки 
------------------------------
Как и большинство современных языков Питон обладает возможностями использования ипортируемых модулей и библиотек. Это создает ряд моментов, которые должны заставить разработчиков относиться к этому ответственно. В связи с этим разработчики языка создали то что называется Дзен Питона или Философия Питона:

    Красивое лучше, чем уродливое.
    Явное лучше, чем неявное.
    Простое лучше, чем сложное.
    Сложное лучше, чем запутанное.
    Плоское лучше, чем вложенное.
    Разреженное лучше, чем плотное.
    Читаемость имеет значение.
    Особые случаи не настолько особые, чтобы нарушать правила.
    При этом практичность важнее безупречности.
    Ошибки никогда не должны замалчиваться.
    Если они не замалчиваются явно.
    Встретив двусмысленность, отбрось искушение угадать.
    Должен существовать один и, желательно, только один очевидный способ сделать это.
    Хотя он поначалу может быть и не очевиден, если вы не голландец [*].
    Сейчас лучше, чем никогда.
    Хотя никогда зачастую лучше, чем прямо сейчас.
    Если реализацию сложно объяснить — идея плоха.
    Если реализацию легко объяснить — идея, возможно, хороша.
    Пространства имён — отличная штука! Будем делать их больше!
    
    *Отсылка к нидерландскому программисту, создавшему язык Python, Гвидо ван Россуму (нидерл. Guido van Rossum).

Мы постоянно пользуемся модулями но не обращаем на это внимание, например import sys - это модуль, которые мы берем из стандартного набора модулей. Кроме того мы можем писать свои модули и переиспользовать в различных задачах.

Рассмотрим ряд стандартных библиотек, которые мы можем использовать в ежедневной работе для упрощения ряда задач:

    1. <atexit> регистрирует функцию, которая вызывается перед выходом из программы
    
    2. <argparse> парсит аргументы консольной комманды

    3. <bisect> алгороитм бинарного поиска (тут надеюсь не нужно примеров)

    4. <calendar> генерирует календарь
    
    5. <codecs> модуль предоставляет набор функций для смены кодировки.

    6. <collections> предоставляет набо функций для создания различных типов данных (очереди, словари, списки)

    7. <copy> функции для создания копии объекта либо ссылки на объект
    
    8. <csv> функции для чтения и записи CSV файлов

    9. <datetime> функции работы с датой
    
    10. <fnmatch> функции для поиска 

    11. <concurrent> асинхронное выполнение задач аналогичное с созданием потоков (native in Python 3, available for Python 2 via PyPI). Рассмотрим отдельно

    12. <json> работа с JSON форматом. Рассмотрим отдельно
    
    13. <logging> настройки логгирования для функций
    
    14. <multiprocessing> под процессы для имитации работы мультипоточности. Рассмотрим отдельно

    15. <lambda> анонимные функции , которые описываются в месте их применения

    16. <os> дает доступ к функциям операционной системы
    
    17. <random> функции генерации псевдослучайных чисел
    
    18. <re> предоставляет функциональность регулярных выражений
    
    19. <urllib> обработка и работа с URL
    
    20. <uuid> генерирует уникальный идентификатор

Говоря о внутренних библиотеках, которые мы создаем необходимо понимать, что переиспользование библиотек влечет за собой большую ответстсвенность, так как библиотека может повлиять на любой новый проект, а может даже сломать его. Мы не можем на сто процентов себя обезопасить, так как программисты - тоже люди и гарантировать, что через год или 2 библиотека будет так же совместима с любыми другими библиотеками мы они не могут. Но все же рассмотрим ряд правил, которые нам необходмо соблюдать при написании любой новой библиотеки для внутреннего использования. Эти правила так же будут полезны при выборе сторонней библиотеки для использования в проекте

    1. Совместимость с Python 3. Даже если мы не планируем совместимость с трешкой прямо сейчас - не известно когда именно это нам понадобится в будущем и чего будет стоить. Возможно придется переписывать большую часть проектов, что будет не очень удобно

    2. Активность разработки. Если библиотека давно не поддерживается, корее всего есть причина, по которой не следует использовать эту библиотеку.

    3. Активность поддержки. Так же следует обращать внимание на то как часто и качественно разработчики отвечают на нахождение багов в своих библиотеках. Если сообщество мертвое - это тоже сигнал.

    4. Лицензия. Тоже важный момент - если вы ограничены в использщованиии выбранной библиотеки желательно знать об этом заранее

### Фрэймворки
Фрэймворк это программная среда, некий каркас, используемый для того, чтобы существенно облегчить процесс обхединения компонентов при создании программ. Это основа, которая позволяет добавлять компоненты в зависимости от потребностей. База, на которой можно сформировать программу любого назначения достаточно быстро и без особых затруднений.

Выбор фрэймворка, если он вообще нужен (это зависит от задачи) должен опираться не только на решение текущей задачи , но и на ряд задач, с которыми придется столкнуться в будущем. Огранеичения фрэймворка не должны явно блокировать развитие проекта и не мешать его поддержке, а наоборот. Не забывайте, что фрэймворк - это инструмент, а не религия или культура. Выбор всегда диктуется необходимостью, а не личным предпочтением. Выбирайте с умом.

#### Вот примеры некоторых из них для различных целей

    1. Dash от Plotly hhttps://plotly.com/dash/. Один из самых быстрых и удобных способов создать дашборд с данными на питоне. Кроме того в состеве пакет мы получим еще один фрэймворк и библиотеку для питона, которым можем пользоваться
        - Удобный инструмент для быстрого создания дашборда отображения данных и мониторинга

    2. Flask. Фрэймворк для небольших веб приложений и быстрого старта в разработке. 

    3. Django. Самый функционально наполненный фрэймворк на сегодняшний день
        - быстрый старт в разработке
        - ORM прямо из коробки
        - может быть для API или для полноценного приложения
        - можно интегрировать любые библиотеки например Dash https://   django-dash.herokuapp.com/dashboard/edit/dinesh/
        - можно использовать fullstack библиотеки например https://www.django-unicorn.com/examples/todo


### Функциональное программирование и чистые функции

#### Теория

- Функции высшего порядка
- Чистые функции
- Неизменяемые данные

---

Чистые функции

Чистые функции не производят никаких наблюдаемых побочных эффектов, только возвращают результат. Не меняют глобальных переменных, ничего никуда не посылают и не печатают, не трогают объектов, и так далее. Принимают данные, что-то вычисляют, учитывая только аргументы, и возвращают новые данные.

Плюсы:

Легче читать и понимать код
Легче тестировать (не надо создавать «условий»)
Надежнее, потому что не зависят от «погоды» и состояния окружения, только от аргументов
Можно запускать параллельно, можно кешировать результат

---

Неизменяемые данные

Неизменяемые (иммутабельные) структуры данных - это коллекции, которые нельзя изменить. Примерно как числа. Число просто есть, его нельзя поменять. Также и неизменяемый массив — он такой, каким его создали, и всегда таким будет. Если нужно добавить элемент — придется создать новый массив.

Преимущества неизменяемых структур:

Безопасно разделять ссылку между потоками
Легко тестировать
Легко отследить жизненный цикл

---

Функции высшего порядка

Функцию, принимающую другую функцию в качестве аргумента и/или возвращающую другую функцию, называют функцией высшего порядка:


def f(x):
    return x + 3

def g(function, x):
    return function(x) * function(x)

print(g(f, 7))

---

Списковые включения или генератор списка

Рассмотрим одну конструкцию языка, которая поможет сократить количество строк кода. Не редко уровень программиста на Python можно определить с помощью этой конструкции.

Пример кода:

    for x in xrange(5, 10):
        if x % 2 == 0:
            x =* 2
        else:
            x += 1
Цикл с условием, подобные встречаются не редко. А теперь попробуем эти 5 строк превратить в одну:

[x * 2 if x % 2 == 0 else x + 1 for x in xrange(5, 10)]

---

Замыкания

Функции, определяемые внутри других функций, представляют собой замыкания

    def multiplier(n):
        "multiplier(n) возвращает функцию, умножающую на n" 
        def mul(k): 
            return n*k 
        return mul 

Таким образом мы можем пользоваться функциями в качестве объектов, создавая конструкции содержащие переменные и методы. Но не забывайте, что объект и класс - это разыне вещи. Мы используем фунуции именно как обхект а не как класс.

---

## Тестирование

Тестирование программного обеспечения (Software Testing) - проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая при конечном наборе тестов, выбранном определенным образом.

В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя действия по планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).

Для разработчика же интересней следующее определение:

Тестирование — это проверка соответствия программы требованиям, осуществляемая путем наблюдения за ее работой в специальных, искусственно созданных ситуациях, выбранных определенным образом.

Хочется обратить внимание на слова “искусственно созданных ситуациях, выбранных определенным образом”. Это означает, что не имеет смысла тестировать вообще все ситуации, стоит выбирать критически важные места и сценарии.

### Уровни тестирования

Тестирование для разработчика состоит из написания тестов. Тест - это такой же программный код, который пишется аналогично коду для реализации бизнес-логики. Тесты проверяют сценарии работы программы (test-case).

Тест-кейсы встречаются самые различные, один от другого может резко отличаться. По желанию можно тестировать ВСЕ возможные и невозможные ситуации. Однако, стоит соблюдать адекватность и покрывать тестами ровно на столько, сколько требуется для уверенного понимания, что бизнес-логика работает как задумано.

Например, функция, которая возвращает числовое значение от 0 до 100. В тестах стоит проверить не только правильность значений из этого диапазона, но и то, что других значений не возникает.

Негласное правило - если на участке кода проявилась ошибка, то стоит написать тест на этот случай.

Тестирование смело делится на несколько уровней глубины. Наиболее показательная классификация по уровням тестирования в данном случае такая:

    Системное тестирование – тестирование полностью интегрированного программного приложения

    Интеграционное тестирование – тестирование интегрированных групп программных модулей

    Модульное тестирование или юнит-тестирование – тестирование отдельных модулей исходного кода приложения

Когда говорят "тестирование" не выделяя конкретный тип, то говорят скорее всего о модульном тестировании.

### Модульное тестирование

Модульное тестирование, или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.

Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже протестированных местах программы и облегчает обнаружение и устранение таких ошибок.

Инструменты

В Python для модульного тестирования применяют

    PyUnit
    PyTest
    Nose



### Интеграционное тестирование

Интеграцио́нное тестирование или функциональное тестирование предназначено для проверки связи между компонентами, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами).

Подходы к интеграционному тестированию:

    Снизу вверх (Bottom Up Integration)
    Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули разрабатываемого уровня готовы.

    Сверху вниз (Top Down Integration)
    Вначале тестируются все высокоуровневые модули, и постепенно, один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами.

    Большой взрыв ("Big Bang" Integration)
    Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако, если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования

Инструменты
Для автоматизации интеграционного тестирования применяются системы непрерывной интеграции (Continuous Integration System, CIS). Принцип действия таких систем состоит в следующем:

CIS производит мониторинг системы контроля версий;
При изменении исходных кодов в репозитории производится обновление локального хранилища;
Выполняются необходимые проверки и модульные тесты;
Исходные коды компилируются в готовые выполняемые модули;
Выполняются тесты интеграционного уровня;
Генерируется отчет о тестировании.

Примеры инструментов:

    Jenkins
    TeamCity
    Travis CI

### Системное тестирование

Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты:

    Неверное использование ресурсов системы;
    Непредусмотренные комбинации данных пользовательского уровня;
    Несовместимость с окружением;
    Непредусмотренные сценарии использования;
    Отсутствующая или неверная функциональность,
    Неудобство использования
    И другие.

Для минимизации рисков, связанных с особенностями поведения в системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.

Стоит выделить два подхода к системному тестированию:

    на базе требований (requirements based). Для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования.
    на базе случаев использования (use case based). На основе представления о способах использования продукта создаются случаи использования системы (Use Cases).
    По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся тест кейсы (test cases), которые реализуются в виде тестов.

Инструменты

Для описания сценариев можно использовать BDD ( behavior-driven development)

    pytest-bdd
    behave
    freshen

### Простой инструмент проверки данных - assert

Так как этот урок почти полностью состоит из теории, то разбавлю конструкцией языка, которая помогает писать код и тесты более высокого качества.

Python - язык с динамической типизацией. Это значит, что при написании Python-кода мы явно не указываем тип данных, а во время исполнения не гарантируется явный тип переменной.

В следствии этого возникают сложности. Например, в функции ожидаем целое число, а нам передали list - это может привести к самым неожиданным ошибками. Чтобы попытаться обойти эту проблему стоит воспользоваться assert.

Assert — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы.

Assert'ы позволяют отлавливать ошибки в программах на этапе компиляции либо во время исполнения.

### Тестирование с помощью unittest

unittest - инструмент для тестирования в Python. Это стандартный модуль для написания юнит-тестов на Python. Unittest это порт JUnit с Java. Иными словами, и в коде модуля, и при написании тестов легко прослеживается ООП стиль, что весьма удобно для тестирования процедур и классов.

В данном инструменте много возможностей: проверки (assert*), декораторы, позволяющие пропустить отдельный тест (@skip, @skipIf) или обозначить сломанные тесты (@expectedFailure) и этим не заканчивается список. Использование assert'ов с лихвой покрывает нужды при написании тестов.


## Описание unittest

Полезная черта unittest - автоматизированное тестирование. Есть и другие:

    - можно собирать тесты в группы
    - собирать результаты выполнения тестов (например, для отчета)
    - ООП стиль позволяет уменьшить дублирование кода при схожих объектах тестирования

В использовании unittest присутствуют несколько концепций

### test case

test case -это наименьшая единица тестирования. Он проверяет конкретный ответ для конкретного набора входных данных.


### test suite

test suite представляет собой сборник тестовых случаев, тестовых наборов. Используется для агрегирования тестов, которые должны выполняться вместе

### test fixture

test fixture - это фиксированное состояние объектов используемых в качестве исходного при выполнении тестов.

Цель использования fixture - если у вас сложный test case, то подготовка нужного состояния легко может занимать много ресурсов (например, вы считаете функцию с определенной точностью и каждый следующий знак точности в расчетах занимает день). Используя fixture (на сленге - фикстуры) предварительную подготовку состояния пропускаем и сразу приступаем к тестированию.

Test fixture может выступать, например, в виде:

    - состояние базы данных
    - набор переменных среды
    - набор файлов с необходимым содержанием.

### test runner

test runner - это компонент, который организует выполнение тестов и предоставляет результат пользователю.


## Рекомендации к написанию тестов

При написании тестов следует исходить из следующих принципов:

    - Работа теста не должна зависеть от результатов работы других тестов.
    - Тест должен использовать данные, специально для него подготовленные, и никакие другие.
    - Тест не должен требовать ввода от пользователя
    - Тесты не должны перекрывать друг друга (не надо писать одинаковые тесты 20 раз).Можно писать частично перекрывающие тесты.
    - Нашел баг -> напиши тест
    - Тесты надо поддерживать в рабочем состоянии
    - Модульные тесты не должны проверять производительность сущности (класса, функции)
    - Тесты должны проверять не только то, что сущность работает корректно на корректных данных, но и то что ведет себя адекватно при некорректных данных.
    - Тесты надо запускать регулярно

## Практика
К написанию тестов стоит относится также как и к основному коду.

Написание тестов является хорошей инвестицией в будущее программы:

    - Когда ваша программа становится настолько большой, что не помещается целиком у вас в голове, то это отличный звоночек, что стоит покрывать все тестами
    - Если сейчас ваша программа не испытывает проблем, то через какое-то время библиотеки, которые вы используете, могут начать обновляться без обратной совместимости. Вот здесь-то тесты помогут
    - Когда вы занимаетесь рефакторингом кода - тесты помогут не сломать лишнего
    - Есть и другие причины писать тесты. В целом, практика показывает, что до тестов надо дорасти - в какой-то момент приходит понимание зачем же тратить на них время.

В качестве примеров использования unittest продемонстрирую и опишу основные возможности модуля. На мой взгляд это те 20% которые помогут сделать 80% результата.



### Практические примеры

Перейдем к более практическим примерам. На них и рассмотрим еще некоторые важные способности unittest

    Как тестировать конструктор?
    Как тестировать структуры данных?
    Как тестировать работу с БД?


#### Как тестировать конструктор


В коде видно, что есть класс, в конструкторе которого кидается исключение если значение аргумента не удовлетворяет условию. Это условие ловится функцией self.assertRaises или ее старым названием self.failUnlessRaises

Во втором примере показан тест на количество аргументов в классе.


#### Как тестировать структуру данных?

Продемонстрирую пример тестирования структуры данных. В данном случае есть класс 
Point, в котором хранится два float’а x,y. А дальше весь код такой же как и для других тестов.


#### Как тестировать работу с БД?
Примера под тестирование БД не приведу, однако, расскажу об общих соображениях потому что тестирование БД - это отедльная и очень большая тема.

Работа с базой не так проста, как с обычной функцией, ведь база - это не просто программный код, база данных - это объект, сохраняющий своё состояние. И если мы начнём в процессе тестирования изменять данные в базе, то после каждого теста база будет изменяться. Это может помешать последующим тестам и необратимо испортить базу данных.

Ключ к решению проблемы - транзакции. Одна из особенностей этого механизма состоит в том, что до тех пор пока транзакция не завершена, вы всегда можете отменить все изменения и вернуть базу в состояние на момент начала транзакции. Алгоритм такой:

    - открываем транзакцию;
    - если нужно, выполняем подготовительные действия для тестирования;
    - выполняем модульный тест (или просто запускаем сценарий, работу которого хотим проверить);
    - проверяем результат работы сценария;
    - отменяем транзакцию, возвращая базу данных в исходное состояние.
    - Даже если в тестируемом коде останутся незакрытые транзакции, внешний ROLLBACK всё равно откатит все изменения корректно.

Помимо транзакций стоит обратить внимание, что тестирование следует делать на тестовой базе данных. Идеальным случаем будет полная инициализация окружения перед исполнением теста.

---

## Декораторы в Python

Декоратор – это функция, которая принимает другую функцию в качестве аргумента. Декоратор модифицирует или улучшает принятую функцию и выдает измененную. Это значит, что когда вы вызываете декорированную функцию, вы получите функцию, которая может иметь небольшие отличия, в виде дополнительных функций, совмещенных с базовым определением. Нам нужно рассмотреть основу декоратора, а именно функцию. 

Мы уже рассматривали понятие функций высшего порядка ранее. Декоратор - это та же функция высшег7о порядка но с рядом дополнительных свойств.

### Простая функция

Python Функция - это блок кода, который начинается с ключевого слова def, с дальнейшим названием функции. Функция может принимать от нуля и более аргументов, ключевые аргументы или сочетание этих аргументов. Функция всегда выдает результат. Если вы не определили, что именно она должна выдавать, она выдаст None. Вот очень простой пример функции, которая выдает строку:

    # -*- coding: utf-8 -*-
    def a_function():
        """Обычная функция"""
        return "1+1"
    
    if __name__ == "__main__":
        value = a_function()
        print(value)

Все что мы сделали в этом коде, это вызвали функцию и указали значение выдачи. Давайте создадим другую функцию:

    # -*- coding: utf-8 -*-
    def another_function(func):
        """
        Функция которая принимает другую функцию.
        """
        
        def other_func():
            val = "Результат от %s это %s" % (func(),
                eval(func())
            )
            return val
        
        return other_func

Эта функция принимает один аргумент и этот аргумент должен быть функцией или вызываемой. По факту, ее стоит вызывать, используя определенную в прошлом функцию. Вы заметите, что это функция содержит вложенную внутрь функцию, которую мы называем other_func. Она принимает результат переданной функции, её выражение и создает строку, которая говорит нам о том, что мы сделали, после чего она возвращается.

    # -*- coding: utf-8 -*-
    def another_function(func):
        """
        Функция которая принимает другую функцию.
        """
        
        def other_func():
            val = "Результат от %s это %s" % (func(),
                eval(func())
            )
            
            return val
        return other_func
    
    
    def a_function():
        """Обычная функция"""
        return "1+1"
    
    if __name__ == "__main__":
        value = a_function()
        print(value)
        decorator = another_function(a_function)
        print(decorator())

Так и работает декоратор. Мы создали одну функцию и передали её другой второй функции. Вторая функция является функцией декоратора. Декоратор модифицирует или усиливает функцию, которая была передана и возвращает модификацию. Если вы запустите этот код, вы увидите следующий выход в stdout:
    
    1+1
    Результат от 1+1 это 2

Давайте немного изменим код, чтобы превратить another_function в декоратор:

    decorator_example.py

Обратите внимание на то, что декоратор начинается с символа @, за которым следует название функции, которую мы собираемся «декорировать». Для получения декоратора python, вам нужно только разместить его в строке перед определением функции. Теперь, когда мы вызываем **a_function, она будет декорирована.

### Создание логируемого декоратора

Возможно, вам потребуется логировать того, что делает ваша функция. Большую часть времени логинг будет встроен внутри вашей функции. Однако, бывают случаи, когда вам нужно сделать это на уровне функции, что бы получить представление о потоке программы или, возможно, для следования тем или иным условиям бизнеса, таким как аудит. Посмотрим на небольшой декоратор, который мы можем использовать для записи названия любой функции и того, что она делает:

    decorator_logging_example.py

Этот небольшой скрипт содержит функцию log, которая принимает функцию как единственный аргумент. Мы создаем объект логгер, а название лог файла такое же, как и у функции. После этого, функция log будет записывать, как наша функция была вызвана и что она возвращает, если возвращает.

### Встроенные декораторы

Python содержит несколько встроенных декораторов. Из всех этих декораторов, самой важной троицей являются:

    @classmethod
    @staticmethod
    @property

Также существуют декораторы в различных разделах стандартной библиотеки Python. Одним из примеров является functools.wraps. Мы сосредоточимся на трех главных декораторах, указанных выше.

    Декоратор <*@classmethod>* может быть вызван при помощи экземпляра класса, или напрямую, через собственный класс Python в качестве первого аргумента. В соответствии с документацией Python: он может быть вызван как в классе (например, C.f()), или в экземпляре (например, C().f()). 
    Экземпляр игнорируется, за исключением его класса. Если метод класса вызван для выведенного класса, то объект выведенного класса передается в качестве подразумеваемого первого аргумента.
    
    Декоратор @classmethod, в первую очередь, используется как чередуемый конструктор или вспомогательный метод для инициализации.
    
    Декоратор <*@staticmethod>* — это просто функция внутри класса. Вы можете вызывать их обоих как с инициализацией класса так и без создания экземпляра класса. Обычно это применяется в тех случаях, когда у вас есть функция, которая, по вашему убеждению, имеет связь с классом. По большей части, это выбор стиля.

Если мы взглянем на пример кода, в котором показано, как работает декоратор, это может помочь понять основные принципы:

    decorator_internal_example.py

Этот пример демонстрирует, что вы можете вызывать обычный метод и оба метода декоратора одним и тем же путем. Обратите внимание на то, что вы можете вызывать обе функции @classmethod и @staticmethod прямо из класса или из экземпляра класса. Если вы попытаетесь вызвать обычную функцию при помощи класса (другими словами, DecoratorTest.doubler(2)), вы получите ошибку TypeError. Также стоит обратить внимание на то, что последний оператор вывода показывает, что decor.static_quad возвращает обычную функцию вместо связанного метода.

### Свойства Python (@property)

Python содержит очень удобный небольшой концепт, под названием property, который выполняет несколько полезных задач. Мы рассмотрим, как делать следующее:

    Конвертация метода класс в атрибуты только для чтения;
    Как реализовать сеттеры и геттеры в атрибут

Один из самых простых способов использования property, это использовать его в качестве декоратора метода. Это позволит вам превратить метод класса в атрибут класса. Для меня это было очень полезно, когда мне нужно сделать какую-нибудь комбинацию значений.

Для других это было очень кстати при написании методов конверсии, которые нужно было принять в качестве методов. Давайте взглянем на простой пример:

    decorator_property_example.py

Как вы видите, в результате превращение метода в свойство, мы можем получить к нему доступ при помощи обычной точечной нотации. Однако, если мы попытаемся настроить свойство на что-то другое, мы получим ошибку AttributeError. Единственный способ изменить свойство full_name, это сделать это косвенно:

    person.first_name = "Денис"

Это своего рода ограничение, так что взглянем на другой пример, где мы можем создать свойство, которое позволяет нам делать настройки.

### Замена сеттеров и геттеров на свойство Python

Давайте представим, что у нас есть код, который написал кто-то, кто не очень понимает Python. Как и я, вы скорее всего, видели такого рода код ранее:

    decorator_set_get_example.py


Если вам нужно добавить обычную точечную нотацию атрибутов в данный код без выведения из строя всех приложений в этой части кода, вы можете сделать это очень просто, добавив свойство:

     fee = property(get_fee, set_fee)

Как мы видим, когда мы используем свойство таким образом, это позволяет свойству fee настраивать и получать значение без поломки наследуемого кода. Давайте перепишем этот код с использованием декоратора property, и посмотрим, можем ли мы получить его для разрешения установки.

### Подведем итоги

С этого момента вы должны понимать, как создавать собственные декораторы и как использовать встроенные декораторы Python. Мы рассмотрели classmethod, @property и @staticmethod. Надеюсь, вы будете использовать встроенные декораторы, и создавать свои собственные.

---

## Жизненный цикл объекта

Создадим простой класс

    class Number:
        def __init__(self, value):
            self.value = value

    n = Number(5)

### Метаклассы 
Классы в Питон - тоже объекты
    
    type(Number())
    <class '__main__ Number'>

    type(Number)
    <class 'type'>

Можно динамически создать

    type (<имя класса>, 
          <кортеж родительских классов>, # для наследования может быть пустым
          <словарь, содержащий атрибуты и их значения>)

    def number2_init(self, value):
        self.value = value

    Number = type('Number2', (), {'__init__': number2_init } )

Метаклассы – это классы, экземпляры которых являются классами. Давайте поговорим о специфике языка Python и его функционале.

Если говорить в двух словах, то метакласс – это "штуковина", создающая классы. Чтобы создавать объекты, мы определяем классы, правильно? Но мы узнали, что классы в Python являются объектами. На самом деле метаклассы – это то, что создает данные объекты. Довольно сложно объяснить. Лучше приведем пример:

    MyClass = MetaClass()
    my_object = MyClass()

Ранее уже упоминалось, что type позволяет делать что-то вроде этого:

    MyClass = type('MyClass', (), {})

Скорее всего, вы задаетесь вопросом: почему имя функции пишется с маленькой буквы?

Скорее всего, это вопрос соответствия со str – классом, который отвечает за создание строк, и int – классом, создающим целочисленные объекты. type – это просто класс, создающий объекты класса. Проверить можно с помощью атрибута __class__. Все, что вы видите в Python – объекты. В том числе и строки, числа, классы и функции. Все это объекты, и все они были созданы из класса:

    >>> age = 35
    >>> age.__class__
    <type 'int'>
    >>> name = 'bob'
    >>> name.__class__
    <type 'str'>
    >>> def foo(): pass
    >>> foo.__class__
    <type 'function'>
    >>> class Bar(object): pass
    >>> b = Bar()
    >>> b.__class__
    <class '__main__.Bar'>

Можно сделать вывод, что метакласс создает объекты класса. Это можно назвать "фабрикой классов". type – встроенный метакласс, который использует Python. Также можно создать свой собственный метакласс.

### Атрибут __metaclass__

При написании класса можно добавить атрибут __metaclass__:

    class Foo(object):
        __metaclass__ = something...
        [...]

Если это сделать, то для создания класса Foo Python будет использовать метакласс.

СТОИТ ПОМНИТЬ!

Если написать class Foo(object), объект класса Foo не сразу создастся в памяти.
Python будет искать __metaclass__. Как только атрибут будет найден, он используется для создания класса Foo. В том случае, если этого не произойдет, Python будет использовать type для создания класса.

Если написать:

    class Foo(Bar):
        pass

Python делает следующее:

Проверит, есть ли атрибут __metaclass__ у класса Foo? Если он есть, создаст в памяти объект класса с именем Foo с использованием того, что находится в __metaclass__.

Если Python вдруг не сможет найти __metaclass__, он будет искать этот атрибут на уровне модуля и после этого повторит процедуру. В случае если он вообще не может найти какой-либо __metaclass__, Python использует собственный метакласс type, чтобы создать объект класса.

Теперь вопрос: что можно добавить в __metaclass__?
Ответ: что угодно, что может создавать классы.

А что может создать класс? type или его подклассы, а также всё, что его использует.

### Пользовательские метаклассы

Основной целью метакласса является автоматическое изменение класса во время его создания. Обычно это делается для API, когда нужно создать классы, соответствующие текущему контексту. Например, вы решили, что все классы в модуле должны иметь свои атрибуты, и они должны быть записаны в верхнем регистре. Чтобы решить эту задачу, можно задать __metaclass__ на уровне модуля.

Таким образом, нужно просто сообщить метаклассу, что все атрибуты должны быть в верхнем регистре. __metaclass__ действительно может быть любым вызываемым объектом, он не обязательно должен быть формальным классом. Итак, начнем с простого примера, с использованием функции.

    metacalss_function_exmaple.py
    metacalss_class_exmaple.py

Причина сложности кода, использующего метаклассы, заключается не в самих метаклассах. Код сложный потому, что обычно метаклассы используются для сложных задач, основанных на наследовании, интроспекции и манипуляции такими переменными, как __dict__. Также с помощью метаклассов можно:

    перехватить создание класса
    изменить класс
    вернуть измененный класс

В основном метаклассы используются для создания API. Типичным примером является Django ORM. Можно написать что-то вроде этого:
    
    class Person(models.Model):
        name = models.CharField(max_length=30)
        age = models.IntegerField()

    но если сделать так 

    guy = Person(name='bob', age='35')
    print(guy.age)

    Он не вернет объект IntegerField. Он вернет код int и даже может взять его непосредственно из базы данных.


## Цикл жизни объекта

Вызов 

    Берем метакласс и вызываем __new__
    __new__ возыращает экземпляр класса
    Интерпретатор вызывает __init__ у экземпляра класса

    # через __dict__ мы перебираем все параметры
    # __getattribute__('value') ищем аттриубы вверх
    # __getattr__ - вызывается если __getattribute__ - вызвал исключение

    class Number:
        def __init__(self, value):
            self.value = value

        def __add__(self, target):
            return Number(self.value + target.value)

    a = Number(5)
    b = Number(6)
    (a + b).value

Удаление

    Метод __del__ вызывается когда Питон удаляет объект, но возможно
    Нет гарантии вызова
    Может вызываться несколько раз

    не нужно им пользоваться
    использовать менеджер контекста try / finally

    try:
    with open("counterfile") as infile:
        _count = int(infile.read())
    
    *пример

    Чтобы разобраться как этим пользоваться перейдем к следубщей теме

---

## Работа с конеткстным менеджером и ресурсами

Контекстные менеджеры позволяют задать поведение при работе с конструкцией with: при входе и выходе из блока. Это упрощает работу с ресурсами в части их захвата и освобождения; транзакциями, когда нужно либо полностью закончить транзакцию, либо откатить ее целиком. Этой теме будет посвящен данный урок.

    - Работа с контекстным менеджером
    - Создание своего контекстного менеджера
    - Работа с contextlib

### Работа с контекстным менеджером

Рассмотрим пример, на котором будут показаны преимущества работы с контекстным менеджером. Задача состоит в следующем: записать в файл file.txt строку hello.

Самый простой способ ее решить – это воспользоваться функцией open() для открытия файла и записать в него данные через функцию write(). При этом нужно не забыть освободить ресурс, вызвав функцию close().

    f = open(‘file.txt’, ‘w’)
    f.write(‘hello’)
    f.close()

Но это не очень хорошее решение, если в процессе работы с файлом (запись, чтение), произошло исключение, то функция close() не будет вызвана, что влечет за собой возможную потерю данных. Для решения этого вопроса воспользуемся обработкой исключения:

    f = open('file.txt', 'w')
    try:
        f.write('hello')
    except:
        print('Some error!')
    finally:
        f.close()

Для того, чтобы не писать дополнительный код, связанный с обработкой исключений (это неудобно и об этом можно забыть), можно воспользоваться конструкцией with… as:

    with open('file.txt', 'w') as f:
        f.write('hello')

Такая конструкция позволяет захватить ресурс (в данном случае файл), выполнить нужный набор операций (запись данных), а перед выходом – освободить ресурс.


### Создание своего контекстного менеджера

Если сущность, которую вы создаете, по стилю работы с ней похожа на файл, т.е. предполагает захват ресурса и освобождение, либо требует выполнения определенных действий перед началом работы и при завершении, то хорошим решением будет создать свой контекстный менеджер, с которым можно будет работать с помощью конструкции with..as. Для этого, в класс необходимо добавить два метода: __enter__ и __exit__.

Перед тем как перейти к примеру, демонстрирующему работу с этими функциями, рассмотрим, что происходит (какие методы и в каком порядке вызываются) в конструкции:

    with open('file.txt', 'w') as file_data:
        file_data.write('hello')

    1. Оператор with сохраняет метод __exit__ класса File.
    2. Вызывается метод __enter__ класса File.
    3. __enter__ открывает файл и возвращает его.
    4. Дескриптор открытого класса передается в file_data.
    5. В файл записываются данные через метод write.
    6. Вызывается сохраненный метод __exit__, который закрывает файл.

Если внутри конструкции with происходит исключение, то оно передается в метод __exit__, в котором производится его обработка и освобождение ресурсов (закрытие файла).

### Пример реализации контекстного менеджера

Создадим класс, у объекта которого необходимо вызывать метод post_work() перед прекращением работы с ним:

    context_selfmade_example.py

### Работа с contextlib

В стандартную библиотеку Python входит модуль contextlib, который содержит утилиты для построения и работы с контекстными менеджерами.

Рассмотрим только один инструмент из всего набора – contextmanager. contextmanager используется как декоратор для функции, превращая ее в контекстный менеджер. При этом схема конструирования такая: все, что написано до оператора yield вызывается в рамках функции __enter__, а все что после – в рамках __exit__.

Рассмотрим несколько примеров:

    context_manager_example.py

---

## Итератор и генератор

Генераторы и итераторы представляют собой инструменты, которые, как правило, используются для поточной обработки данных. В уроке рассмотрим концепцию итераторов в Python, научимся создавать свои итераторы и разберемся как работать с генераторами.

### Итераторы в языке Python

Во многих современных языках программирования используют такие сущности как итераторы. Основное их назначение – это упрощение навигации по элементам объекта, который, как правило, представляет собой некоторую коллекцию (список, словарь и т.п.). Язык Python, в этом случае, не исключение и в нем тоже есть поддержка итераторов. Итератор представляет собой объект перечислитель, который для данного объекта выдает следующий элемент, либо бросает исключение, если элементов больше нет.

Основное место использования итераторов – это цикл for. Если вы перебираете элементы в некотором списке или символы в строке с помощью цикла for, то ,фактически, это означает, что при каждой итерации цикла происходит обращение к итератору, содержащемуся в строке/списке, с требованием выдать следующий элемент, если элементов в объекте больше нет, то итератор генерирует исключение, обрабатываемое в рамках цикла for незаметно для пользователя.

Приведем несколько примеров, которые помогут лучше понять эту концепцию. Для начала выведем элементы произвольного списка на экран.

    num_list = [1, 2, 3, 4, 5]
    for i in num_list:
    print(i)

Как уже было сказано, объекты, элементы которых можно перебирать в цикле for, содержат в себе объект итератор, для того, чтобы его получить необходимо использовать функцию iter(), а для извлечения следующего элемента из итератора – функцию next().

    >>> itr = iter(num_list)
    >>> print(next(itr))
    1
    >>> print(next(itr))
    2
    >>> print(next(itr))
    3
    >>> print(next(itr))
    4
    >>> print(next(itr))
    5
    >>> print(next(itr))
    Ошибка

Как видно из приведенного выше примера вызов функции next(itr) каждый раз возвращает следующий элемент из списка, а когда эти элементы заканчиваются, генерируется исключение StopIteration

### Создание собственных итераторов

Если нужно обойти элементы внутри объекта вашего собственного класса, необходимо построить свой итератор. Создадим класс, объект которого будет итератором, выдающим определенное количество единиц, которое пользователь задает при создании объекта. Такой класс будет содержать конструктор, принимающий на вход количество единиц и метод __next__(), без него экземпляры данного класса не будут итераторами.

    iterator_example.py

В нашем примере при четвертом вызове функции next() будет выброшено исключение StopIteration. Если мы хотим, чтобы с данным объектом можно было работать в цикле for, то в класс SimpleIterator нужно добавить метод __iter__(), который возвращает итератор, в данном случае этот метод должен возвращать self.

    iterator_example_2.py

### Генераторы

Генераторы позволяют значительно упростить работу по конструированию итераторов. В предыдущих примерах, для построения итератора и работы с ним, мы создавали отдельный класс. Генератор – это функция, которая будучи вызванной в функции next() возвращает следующий объект согласно алгоритму ее работы. Вместо ключевого слова return в генераторе используется yield. Проще всего работу генератор посмотреть на примере. Напишем функцию, которая генерирует необходимое нам количество единиц.

    generator_example.py

Данная функция будет работать точно также, как класс SimpleIterator из предыдущего примера.

Ключевым моментом для понимания работы генераторов является то, при вызове yield функция не прекращает свою работу, а “замораживается” до очередной итерации, запускаемой функцией next(). Если вы в своем генераторе, где-то используете ключевое слово return, то дойдя до этого места будет выброшено исключение StopIteration, а если после ключевого слова return поместить какую-либо информацию, то она будет добавлена к описанию StopIteration.

---

## Профилирование кода 

Профилирование кода это попытка найти узкие места в вашем коде. Профилирование может найти самые долго выполняющиеся части вашего кода. Найдя их, вы можете оптимизировать эти части удобным вам способом. Python содержит три встроенных профайлера: cProfile, profile и hotshot. В соответствии с документацией Python, hotshot «не поддерживается, и может быть удален из Python». Модуль profile это в корне своем модуль Python, но добавляет много чего сверху в профилированные программы. Поэтому мы сфокусируемся на cProfile, который содержит интерфейс, который имитирует модуль profile.


### Профилирование кода при помощи cProfile

Профилирование кода с cProfile это достаточно просто. Все что вам нужно сделать, это импортировать модуль и вызвать его функцию run. Давайте посмотрим на простой пример:

    import hashlib
    import cProfile
    
    cProfile.run("hashlib.md5(b'abcdefghijkl').digest()")

Здесь мы импортировали модуль hashlib и использовали cProfile для профилирования того, что создал хеш MD5. Первая строка показывает, что в ней 4 вызова функций. Следующая строка говорит нам, в каком порядке результаты выдачи. Здесь есть несколько столбцов.

    ncalls – это количество совершенных вызовов;
    tottime – это все время, потраченное в данной функции;
    percall – ссылается на коэффициент tottime, деленный на ncalls;
    cumtime – совокупное время, потраченное как в данной функции, так и наследуемых функциях. Это работает также и с рекурсивными функциями!
    Второй столбец percall – это коэффициент cumtime деленный на примитивные вызовы;
    filename:lineno(function) предоставляет соответствующие данные о каждой функции.

Профилирование кода — Как найти слабое звено?

 

Профилирование кода это попытка найти узкие места в вашем коде. Профилирование может найти самые долго выполняющиеся части вашего кода. Найдя их, вы можете оптимизировать эти части удобным вам способом. Python содержит три встроенных профайлера: cProfile, profile и hotshot. В соответствии с документацией Python, hotshot «не поддерживается, и может быть удален из Python». Модуль profile это в корне своем модуль Python, но добавляет много чего сверху в профилированные программы. Поэтому мы сфокусируемся на cProfile, который содержит интерфейс, который имитирует модуль profile.

Профилирование кода при помощи cProfile
Профилирование кода с cProfile это достаточно просто. Все что вам нужно сделать, это импортировать модуль и вызвать его функцию run. Давайте посмотрим на простой пример:

Python
import hashlib
import cProfile

cProfile.run("hashlib.md5(b'abcdefghijkl').digest()")
1
2
3
4
import hashlib
import cProfile
 
cProfile.run("hashlib.md5(b'abcdefghijkl').digest()")
Профилирование кода - Как найти слабое звено?

Здесь мы импортировали модуль hashlib и использовали cProfile для профилирования того, что создал хеш MD5. Первая строка показывает, что в ней 4 вызова функций. Следующая строка говорит нам, в каком порядке результаты выдачи. Здесь есть несколько столбцов.

    ncalls – это количество совершенных вызовов;
    tottime – это все время, потраченное в данной функции;
    percall – ссылается на коэффициент tottime, деленный на ncalls;
    cumtime – совокупное время, потраченное как в данной функции, так и наследуемых функциях. Это работает также и с рекурсивными функциями!
    Второй столбец percall – это коэффициент cumtime деленный на примитивные вызовы;
    filename:lineno(function) предоставляет соответствующие данные о каждой функции.

Примитивный вызов – это вызов, который не был совершен при помощи рекурсии. Это очень интересный пример, так как здесь нет очевидных узких мест. Давайте создадим часть кода с узкими местами, и посмотрим, обнаружит ли их профайлер.

    profile_example_2.py

 В этом примере мы создали четыре функции. Первые три работают с разными темпами. Быстрая функция запустится с нормальной скоростью, средняя функция потратит примерно полсекунды на запуск, медленная функция потратит примерно три секунды для запуска. Главная функция вызывает остальные три. Давайте запустим cProfile в этой маленькой глупой программе:

    profile_test_example.py

На этот раз мы видим, что у программы ушло 3.5 секунды на запуск. Если вы изучите результаты, то увидите, что cProfile выявил медленную функцию, которая тратит 3 секунды на запуск. Это и есть самая «слабая» часть основной функции. Обычно, когда вы обнаруживаете такие места, вы можете попытаться найти самый быстрый способ выполнения вашего кода, или прийти к выводу, что такая задержка приемлема. В этом примере, мы знаем, что лучший способ ускорить функцию, то убрать вызов time.sleep, или, по крайней мере, снизить продолжительность сна. Вы можете также вызвать cProfile в командной строке, вместо применения в интерпретаторе. Как это сделать:

    python3 -m cProfile file.py

Таким образом, будет запущен cProfile в вашем скрипте по аналогии с тем, как мы делали это ранее. Но что если вам нужно сохранить выдачу профайлера? Что-ж, это очень просто с cProfile! Все что вам нужно, это передать ему команду –o, за которой следует название (или путь) файла выдачи. Вот пример:

    python -m cProfile -o output.txt file.py

### Выясняем скорость загрузки сайтов

Давайте немного развлечемся. Сделаем небольшой марафон и узнаем какой сайт быстрее всех откроется из нашей программы.

    profile+site_check.py

Мы получим большой список результатов, давайте найдем только наши функции. Запуск всех сайтов выполнился в 2.68 секунды. Быстрее всех открылся Twitter, самый медленный стал VK. Это конечно не идеальный тест скорости, но наша задача была выполнена. Мы выясняли скорость открытия сайтов используя cProfile.